#!/usr/bin/env bash

# ============================================================================
# WeChat Work Hook for Claude Code
# ============================================================================
#
# This script is triggered by Claude Code hooks (Stop, SessionEnd) to send
# notifications to WeChat Work (企业微信) via webhook.
#
# REQUIRED ENVIRONMENT VARIABLES:
#   CLAUDE_HOOK_WECHAT_URL - WeChat Work webhook URL
#     Example: https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=YOUR_KEY
#
# OPTIONAL ENVIRONMENT VARIABLES:
#   CLAUDE_HOOK_DISABLE - Set to prevent infinite recursion when calling Claude CLI
#   CLAUDE_HOOK_TIMEOUT - Claude CLI timeout in seconds (default: 30)
#   CLAUDE_HOOK_LOG_LINES - Number of session log lines to extract (default: 10)
#
# INPUT (via STDIN):
#   JSON object with fields:
#     - session_id: Claude session identifier
#     - transcript_path: Path to session log file (JSONL format)
#     - cwd: Current working directory
#     - hook_event_name: Event type (Stop, SessionEnd)
#
# OUTPUT:
#   Sends formatted notification with:
#     - Project name (extracted from git)
#     - Task summary (generated by Claude CLI)
#     - Task status (SUCCESS/FAILED/IN_PROGRESS)
#     - Device and timestamp information
#
# NOTIFICATION TEMPLATE:
#   The notification uses templates/notification.md for message formatting.
#   Variables are replaced: {PROJECT_NAME}, {TASK_NAME}, {TASK_STATUS}, etc.
#
# CLAUDE CLI ANALYSIS:
#   Uses templates/task_info_prompt.txt as system prompt to analyze session
#   logs and extract task information intelligently.
#
# ============================================================================

# Prevent infinite recursion when called from within Claude Code
if [[ -n "${CLAUDE_HOOK_DISABLE:-}" ]]; then
    exit 0
fi

set -euo pipefail

# ============================================================================
# Global Variables
# ============================================================================

CLAUDE_HOOK_WECHAT_URL="${CLAUDE_HOOK_WECHAT_URL:-}"
CLAUDE_HOOK_TIMEOUT="${CLAUDE_HOOK_TIMEOUT:-30}"
CLAUDE_HOOK_LOG_LINES="${CLAUDE_HOOK_LOG_LINES:-10}"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TEMPLATES_DIR="${SCRIPT_DIR}/templates"

# Hook input data
INPUT_JSON=""
SESSION_ID=""
TRANSCRIPT_PATH=""
CWD=""
HOOK_EVENT_NAME=""

# Task information
PROJECT_NAME=""
DEVICE_NAME=""
GIT_BRANCH=""
SESSION_CONTENT=""
TASK_NAME=""
TASK_STATUS=""
TASK_DETAILS=""

# ============================================================================
# Logging Functions
# ============================================================================

log_info() {
    local sid="${SESSION_ID:-N/A}"
    echo "[INFO] [${sid}] $*" >&2
}

log_error() {
    local sid="${SESSION_ID:-N/A}"
    echo "[ERROR] [${sid}] $*" >&2
}

log_finished() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Hook finished: ${SESSION_ID}" >&2
}

# ============================================================================
# Input Processing Module
# ============================================================================

# Read hook input from STDIN
read_hook_input() {
    INPUT_JSON=$(cat)
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Hook called with input: ${INPUT_JSON}" >&2

    if [[ -z "${INPUT_JSON}" ]]; then
        log_error "No hook input data received"
        return 1
    fi
    return 0
}

# Parse input data
parse_input() {
    SESSION_ID=$(echo "${INPUT_JSON}" | jq -r '.session_id // ""')
    TRANSCRIPT_PATH=$(echo "${INPUT_JSON}" | jq -r '.transcript_path // ""')
    CWD=$(echo "${INPUT_JSON}" | jq -r '.cwd // ""')
    HOOK_EVENT_NAME=$(echo "${INPUT_JSON}" | jq -r '.hook_event_name // ""')

    log_info "Hook event: ${HOOK_EVENT_NAME}"
    log_info "Session ID: ${SESSION_ID}"
    log_info "Working directory: ${CWD}"
}

# Check if this event should be processed
should_process_event() {
    if [[ "${HOOK_EVENT_NAME}" != "Stop" && "${HOOK_EVENT_NAME}" != "SessionEnd" ]]; then
        log_info "Skipping non-terminal event"
        return 1
    fi
    return 0
}

# Validate transcript path
validate_transcript_path() {
    if [[ -z "${TRANSCRIPT_PATH}" || ! -f "${TRANSCRIPT_PATH}" ]]; then
        log_error "Invalid or missing transcript_path: ${TRANSCRIPT_PATH}"
        return 1
    fi
    return 0
}

# ============================================================================
# Data Extraction Module
# ============================================================================

# Extract session content
extract_session_content() {
    log_info "Extracting last ${CLAUDE_HOOK_LOG_LINES} lines from session log..."
    SESSION_CONTENT=$(tail -n "${CLAUDE_HOOK_LOG_LINES}" "${TRANSCRIPT_PATH}")

    if [[ -z "${SESSION_CONTENT}" ]]; then
        log_error "Unable to extract session content"
        return 1
    fi
    return 0
}

# Get project name from git repository
get_project_name() {
    log_info "Extracting project name..."
    PROJECT_NAME=""

    if [[ -d "${CWD}/.git" ]]; then
        cd "${CWD}"
        # Try to get repository name from git remote
        local remote_url
        remote_url=$(git remote get-url origin 2>/dev/null || echo "")

        if [[ -n "${remote_url}" ]]; then
            # Extract repository name from URL and remove .git suffix
            PROJECT_NAME=$(basename "${remote_url}" .git)
        else
            # No remote found, use top-level directory name
            PROJECT_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null || echo "${CWD}")")
        fi
    else
        # Not a git repository, use current directory name
        PROJECT_NAME=$(basename "${CWD}")
    fi

    log_info "Project name: ${PROJECT_NAME}"
}

# Get device name
get_device_name() {
    DEVICE_NAME="$(whoami)@$(hostname)"
    log_info "Device name: ${DEVICE_NAME}"
}

# Get git branch
get_git_branch() {
    log_info "Extracting git branch..."
    GIT_BRANCH=""

    cd "${CWD}"
    # Check if inside a git repository (works for both regular repos and worktrees)
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        # Get current branch name
        GIT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "")
    fi

    if [[ -z "${GIT_BRANCH}" ]]; then
        GIT_BRANCH="unknown"
    fi

    log_info "Git branch: ${GIT_BRANCH}"
}

# ============================================================================
# Analysis Module
# ============================================================================

# Analyze content using Claude CLI
analyze_with_claude() {
    log_info "Analyzing content with Claude CLI..."

    # Read system prompt file
    local system_prompt_file="${TEMPLATES_DIR}/task_info_prompt.txt"
    if [[ ! -f "${system_prompt_file}" ]]; then
        log_error "System prompt file not found: ${system_prompt_file}"
        return 1
    fi

    # Read system prompt content
    local system_prompt
    system_prompt=$(cat "${system_prompt_file}")

    # Build user prompt with session content
    local user_prompt
    user_prompt="<input_data>
<format>JSONL (JSON Lines)</format>
<content>
${SESSION_CONTENT}
</content>
</input_data>"

    # Debug information
    log_info "System prompt size: $(echo -n "${system_prompt}" | wc -c) bytes"
    log_info "User prompt size: $(echo -n "${user_prompt}" | wc -c) bytes"

    # Call Claude CLI with system prompt
    log_info "Calling Claude CLI (timeout: ${CLAUDE_HOOK_TIMEOUT}s)..."

    # Use temporary file to capture stderr
    local temp_stderr
    temp_stderr=$(mktemp)

    local claude_output
    local exit_code

    claude_output=$(echo "${user_prompt}" | CLAUDE_HOOK_DISABLE=1 timeout "${CLAUDE_HOOK_TIMEOUT}" claude -p --system-prompt "${system_prompt}" 2>"${temp_stderr}" || echo "")
    exit_code=$?

    # Read stderr content
    local stderr_content
    stderr_content=$(cat "${temp_stderr}")
    rm -f "${temp_stderr}"

    # Output debug information
    log_info "Claude CLI exit code: ${exit_code}"

    if [[ -n "${stderr_content}" ]]; then
        log_error "Claude CLI stderr: ${stderr_content}"
    fi

    if [[ -n "${claude_output}" ]]; then
        log_info "Claude CLI output size: $(echo -n "${claude_output}" | wc -c) bytes"
    else
        log_error "Claude CLI output is empty"
    fi

    # Check for timeout
    if [[ ${exit_code} -eq 124 ]]; then
        log_error "Claude CLI call timed out (${CLAUDE_HOOK_TIMEOUT}s)"
        return 1
    fi

    # Check for other errors
    if [[ ${exit_code} -ne 0 ]]; then
        log_error "Claude CLI call failed with exit code: ${exit_code}"
        return 1
    fi

    # Parse Claude output
    parse_claude_output "${claude_output}"
}

# Parse Claude CLI output
parse_claude_output() {
    local claude_output="$1"

    if [[ -z "${claude_output}" ]]; then
        log_error "Claude CLI returned no result, using defaults"
        use_default_task_info
        return 0
    fi

    # Extract JSON (may be wrapped in markdown code block)
    local json_output
    json_output=$(echo "${claude_output}" | sed -n '/^```json$/,/^```$/p' | sed '1d;$d')

    # If no code block found, try to parse directly
    if [[ -z "${json_output}" ]]; then
        json_output="${claude_output}"
    fi

    # Parse JSON data
    if echo "${json_output}" | jq -e . >/dev/null 2>&1; then
        TASK_NAME=$(echo "${json_output}" | jq -r '.task_name // "Claude Session"')
        TASK_STATUS=$(echo "${json_output}" | jq -r '.task_status // "COMPLETED"')
        TASK_DETAILS=$(echo "${json_output}" | jq -r '.task_details // "Session ended"')
    else
        log_error "Claude CLI returned invalid JSON, using defaults"
        log_error "Claude output: ${claude_output}"
        use_default_task_info
    fi

    log_info "Task name: ${TASK_NAME}"
    log_info "Task status: ${TASK_STATUS}"
}

# Use default task information
use_default_task_info() {
    TASK_NAME="Claude Session"
    TASK_STATUS="COMPLETED"
    TASK_DETAILS="Session ended. Please check session log for details."
}

# ============================================================================
# Notification Module
# ============================================================================

# Build notification JSON
build_notification_json() {
    local notification_json
    notification_json=$(jq -n \
        --arg session_id "${SESSION_ID}" \
        --arg project_name "${PROJECT_NAME}" \
        --arg git_branch "${GIT_BRANCH}" \
        --arg task_name "${TASK_NAME}" \
        --arg task_status "${TASK_STATUS}" \
        --arg event_device "${DEVICE_NAME}" \
        --arg task_details "${TASK_DETAILS}" \
        --arg notification_url "${CLAUDE_HOOK_WECHAT_URL:-}" \
        '{
            "session_id": $session_id,
            "project_name": $project_name,
            "git_branch": $git_branch,
            "task_name": $task_name,
            "task_status": $task_status,
            "event_device": $event_device,
            "task_details": $task_details,
            "notification_template": "notification.md",
            "notification_url": $notification_url
        }')

    echo "${notification_json}"
}

# Send notification
send_notification() {
    local notification_json="$1"

    # Check if notification URL is configured
    if [[ -z "${CLAUDE_HOOK_WECHAT_URL:-}" ]]; then
        log_error "Warning: CLAUDE_HOOK_WECHAT_URL not configured, skipping notification"
        log_info "Notification content:"
        echo "${notification_json}" >&2
        return 0
    fi

    # Use notification.sh to send notification
    log_info "Sending notification..."
    if echo "${notification_json}" | "${SCRIPT_DIR}/notification.sh"; then
        log_info "Notification sent successfully"
        return 0
    else
        log_error "Notification failed to send"
        return 1
    fi
}

# ============================================================================
# Main Flow
# ============================================================================

main() {
    # 1. Input processing
    read_hook_input || exit 1
    parse_input
    should_process_event || exit 0
    validate_transcript_path || exit 1

    # 2. Data extraction
    extract_session_content || exit 1
    get_project_name
    get_device_name
    get_git_branch

    # 3. Content analysis
    analyze_with_claude || use_default_task_info

    # 4. Send notification
    local notification_json
    notification_json=$(build_notification_json)
    send_notification "${notification_json}" || exit 1

    log_finished
}

# Execute main function
main
